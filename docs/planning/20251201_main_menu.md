# Main Menu Implementation

**Date:** December 1, 2025  
**Priority:** HIGH  
**Estimated Time:** 3-4 hours  
**Dependencies:** Pause System (optional)

## Objective

Create a professional main menu screen that displays on game load, with options to start game, view high scores, adjust settings, and view credits.

## Current State

**What Exists:**
- ✅ Game starts immediately on load
- ✅ High score system with localStorage
- ✅ Audio system with mute toggle
- ✅ GameState with MENU state

**What's Missing:**
- ❌ No title screen
- ❌ No start button
- ❌ No high scores display
- ❌ No settings menu
- ❌ No credits screen
- ❌ Game initializes gameplay immediately

## Architecture

### Menu System Structure

```
MainMenu (container)
├── TitleScreen (default view)
│   ├── Title text
│   ├── Start button
│   ├── High Scores button
│   ├── Settings button
│   └── Credits button
├── HighScoresScreen (sub-view)
│   ├── Score list
│   └── Back button
├── SettingsScreen (sub-view)
│   ├── Volume slider
│   ├── Mute toggle
│   └── Back button
└── CreditsScreen (sub-view)
    ├── Credits text
    └── Back button
```

## Implementation

### 1. Create Main Menu Manager

**File:** `src/ui/MainMenu.ts` (new)

```typescript
/**
 * Main Menu System
 * Manages title screen and sub-menus
 */
import { Application, Container } from 'pixi.js';
import { TitleScreen } from './TitleScreen';
import { HighScoresScreen } from './HighScoresScreen';
import { SettingsScreen } from './SettingsScreen';
import { CreditsScreen } from './CreditsScreen';

export enum MenuView {
  TITLE = 'title',
  HIGH_SCORES = 'high_scores',
  SETTINGS = 'settings',
  CREDITS = 'credits'
}

export class MainMenu {
  public container: Container;
  private app: Application | null = null;
  private currentView: MenuView = MenuView.TITLE;
  
  // Screens
  private titleScreen: TitleScreen;
  private highScoresScreen: HighScoresScreen;
  private settingsScreen: SettingsScreen;
  private creditsScreen: CreditsScreen;
  
  // Callbacks
  private onStartCallback: (() => void) | null = null;

  constructor() {
    this.container = new Container();
    this.titleScreen = new TitleScreen();
    this.highScoresScreen = new HighScoresScreen();
    this.settingsScreen = new SettingsScreen();
    this.creditsScreen = new CreditsScreen();
  }

  public init(app: Application): void {
    this.app = app;
    
    // Initialize all screens
    this.titleScreen.init(app);
    this.highScoresScreen.init(app);
    this.settingsScreen.init(app);
    this.creditsScreen.init(app);
    
    // Add screens to container
    this.container.addChild(this.titleScreen.container);
    this.container.addChild(this.highScoresScreen.container);
    this.container.addChild(this.settingsScreen.container);
    this.container.addChild(this.creditsScreen.container);
    
    // Set up navigation
    this.setupNavigation();
    
    // Show title screen
    this.showView(MenuView.TITLE);
    
    // Add to stage
    this.app.stage.addChild(this.container);
  }

  private setupNavigation(): void {
    // Title screen buttons
    this.titleScreen.setOnStart(() => this.onStartCallback?.());
    this.titleScreen.setOnHighScores(() => this.showView(MenuView.HIGH_SCORES));
    this.titleScreen.setOnSettings(() => this.showView(MenuView.SETTINGS));
    this.titleScreen.setOnCredits(() => this.showView(MenuView.CREDITS));
    
    // Back buttons
    this.highScoresScreen.setOnBack(() => this.showView(MenuView.TITLE));
    this.settingsScreen.setOnBack(() => this.showView(MenuView.TITLE));
    this.creditsScreen.setOnBack(() => this.showView(MenuView.TITLE));
  }

  private showView(view: MenuView): void {
    this.currentView = view;
    
    // Hide all screens
    this.titleScreen.hide();
    this.highScoresScreen.hide();
    this.settingsScreen.hide();
    this.creditsScreen.hide();
    
    // Show selected screen
    switch (view) {
      case MenuView.TITLE:
        this.titleScreen.show();
        break;
      case MenuView.HIGH_SCORES:
        this.highScoresScreen.show();
        this.highScoresScreen.refresh(); // Update scores
        break;
      case MenuView.SETTINGS:
        this.settingsScreen.show();
        break;
      case MenuView.CREDITS:
        this.creditsScreen.show();
        break;
    }
  }

  public show(): void {
    this.container.visible = true;
    this.showView(MenuView.TITLE);
  }

  public hide(): void {
    this.container.visible = false;
  }

  public setOnStart(callback: () => void): void {
    this.onStartCallback = callback;
  }

  public destroy(): void {
    this.titleScreen.destroy();
    this.highScoresScreen.destroy();
    this.settingsScreen.destroy();
    this.creditsScreen.destroy();
    this.container.destroy({ children: true });
  }
}
```

### 2. Create Title Screen

**File:** `src/ui/TitleScreen.ts` (new)

```typescript
import { Application, Container, Graphics, Text, TextStyle } from 'pixi.js';
import { UI_STYLES } from './styles';
import { GAME_CONFIG } from '../types/constants';

export class TitleScreen {
  public container: Container;
  private onStartCallback: (() => void) | null = null;
  private onHighScoresCallback: (() => void) | null = null;
  private onSettingsCallback: (() => void) | null = null;
  private onCreditsCallback: (() => void) | null = null;

  constructor() {
    this.container = new Container();
  }

  public init(app: Application): void {
    // Background
    const bg = new Graphics();
    bg.rect(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
    bg.fill({ color: 0x000000 });
    this.container.addChild(bg);
    
    // Title
    const titleStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: 72,
      fill: UI_STYLES.COLORS.PRIMARY,
      fontWeight: 'bold'
    });
    const title = new Text({ text: 'KOBAYASHI MARU', style: titleStyle });
    title.anchor.set(0.5);
    title.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 200);
    this.container.addChild(title);
    
    // Subtitle
    const subtitleStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: 24,
      fill: UI_STYLES.COLORS.SECONDARY
    });
    const subtitle = new Text({ text: 'Endless Tower Defense', style: subtitleStyle });
    subtitle.anchor.set(0.5);
    subtitle.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 280);
    this.container.addChild(subtitle);
    
    // Buttons
    const startBtn = this.createButton('START GAME', 400);
    const scoresBtn = this.createButton('HIGH SCORES', 500);
    const settingsBtn = this.createButton('SETTINGS', 600);
    const creditsBtn = this.createButton('CREDITS', 700);
    
    startBtn.on('pointerdown', () => this.onStartCallback?.());
    scoresBtn.on('pointerdown', () => this.onHighScoresCallback?.());
    settingsBtn.on('pointerdown', () => this.onSettingsCallback?.());
    creditsBtn.on('pointerdown', () => this.onCreditsCallback?.());
    
    this.container.addChild(startBtn, scoresBtn, settingsBtn, creditsBtn);
  }

  private createButton(text: string, y: number): Container {
    const button = new Container();
    button.position.set(GAME_CONFIG.WORLD_WIDTH / 2, y);
    button.eventMode = 'static';
    button.cursor = 'pointer';
    
    const bg = new Graphics();
    bg.roundRect(-150, -30, 300, 60, 8);
    bg.fill({ color: UI_STYLES.COLORS.BACKGROUND, alpha: 0.9 });
    bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
    button.addChild(bg);
    
    const textStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: UI_STYLES.FONT_SIZE_LARGE,
      fill: UI_STYLES.COLORS.SECONDARY,
      fontWeight: 'bold'
    });
    const buttonText = new Text({ text, style: textStyle });
    buttonText.anchor.set(0.5);
    button.addChild(buttonText);
    
    button.on('pointerover', () => {
      bg.stroke({ color: UI_STYLES.COLORS.PRIMARY, width: 3 });
      buttonText.style.fill = UI_STYLES.COLORS.PRIMARY;
    });
    
    button.on('pointerout', () => {
      bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
      buttonText.style.fill = UI_STYLES.COLORS.SECONDARY;
    });
    
    return button;
  }

  public show(): void { this.container.visible = true; }
  public hide(): void { this.container.visible = false; }
  public setOnStart(cb: () => void): void { this.onStartCallback = cb; }
  public setOnHighScores(cb: () => void): void { this.onHighScoresCallback = cb; }
  public setOnSettings(cb: () => void): void { this.onSettingsCallback = cb; }
  public setOnCredits(cb: () => void): void { this.onCreditsCallback = cb; }
  public destroy(): void { this.container.destroy({ children: true }); }
}
```

### 3. Create High Scores Screen

**File:** `src/ui/HighScoresScreen.ts` (new)

```typescript
import { Application, Container, Graphics, Text, TextStyle } from 'pixi.js';
import { UI_STYLES } from './styles';
import { GAME_CONFIG } from '../types/constants';
import { HighScoreManager, calculateScore } from './';

export class HighScoresScreen {
  public container: Container;
  private onBackCallback: (() => void) | null = null;
  private scoreTexts: Text[] = [];
  private highScoreManager: HighScoreManager;

  constructor() {
    this.container = new Container();
    this.highScoreManager = new HighScoreManager();
  }

  public init(app: Application): void {
    // Background
    const bg = new Graphics();
    bg.rect(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
    bg.fill({ color: 0x000000 });
    this.container.addChild(bg);
    
    // Title
    const titleStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: 48,
      fill: UI_STYLES.COLORS.PRIMARY,
      fontWeight: 'bold'
    });
    const title = new Text({ text: 'HIGH SCORES', style: titleStyle });
    title.anchor.set(0.5);
    title.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 150);
    this.container.addChild(title);
    
    // Score list (will be populated in refresh())
    this.createScoreList();
    
    // Back button
    const backBtn = this.createButton('BACK', 900);
    backBtn.on('pointerdown', () => this.onBackCallback?.());
    this.container.addChild(backBtn);
  }

  private createScoreList(): void {
    const startY = 250;
    const lineHeight = 50;
    
    for (let i = 0; i < 10; i++) {
      const scoreStyle = new TextStyle({
        fontFamily: UI_STYLES.FONT_FAMILY,
        fontSize: UI_STYLES.FONT_SIZE_MEDIUM,
        fill: UI_STYLES.COLORS.TEXT
      });
      const scoreText = new Text({ text: '', style: scoreStyle });
      scoreText.position.set(GAME_CONFIG.WORLD_WIDTH / 2 - 300, startY + (i * lineHeight));
      this.container.addChild(scoreText);
      this.scoreTexts.push(scoreText);
    }
  }

  public refresh(): void {
    const scores = this.highScoreManager.getTopScores(10);
    
    for (let i = 0; i < 10; i++) {
      if (i < scores.length) {
        const score = scores[i];
        const totalScore = calculateScore(score);
        const date = new Date(score.timestamp).toLocaleDateString();
        this.scoreTexts[i].text = `${i + 1}. ${totalScore.toLocaleString()} pts - Wave ${score.waveReached} - ${date}`;
      } else {
        this.scoreTexts[i].text = `${i + 1}. ---`;
      }
    }
  }

  private createButton(text: string, y: number): Container {
    const button = new Container();
    button.position.set(GAME_CONFIG.WORLD_WIDTH / 2, y);
    button.eventMode = 'static';
    button.cursor = 'pointer';
    
    const bg = new Graphics();
    bg.roundRect(-100, -30, 200, 60, 8);
    bg.fill({ color: UI_STYLES.COLORS.BACKGROUND, alpha: 0.9 });
    bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
    button.addChild(bg);
    
    const textStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: UI_STYLES.FONT_SIZE_LARGE,
      fill: UI_STYLES.COLORS.SECONDARY,
      fontWeight: 'bold'
    });
    const buttonText = new Text({ text, style: textStyle });
    buttonText.anchor.set(0.5);
    button.addChild(buttonText);
    
    button.on('pointerover', () => {
      bg.stroke({ color: UI_STYLES.COLORS.PRIMARY, width: 3 });
      buttonText.style.fill = UI_STYLES.COLORS.PRIMARY;
    });
    
    button.on('pointerout', () => {
      bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
      buttonText.style.fill = UI_STYLES.COLORS.SECONDARY;
    });
    
    return button;
  }

  public show(): void { this.container.visible = true; }
  public hide(): void { this.container.visible = false; }
  public setOnBack(cb: () => void): void { this.onBackCallback = cb; }
  public destroy(): void { this.container.destroy({ children: true }); }
}
```

### 4. Create Settings Screen

**File:** `src/ui/SettingsScreen.ts` (new)

```typescript
import { Application, Container, Graphics, Text, TextStyle } from 'pixi.js';
import { UI_STYLES } from './styles';
import { GAME_CONFIG } from '../types/constants';
import { AudioManager } from '../audio';

export class SettingsScreen {
  public container: Container;
  private onBackCallback: (() => void) | null = null;
  private muteButton: Container;
  private muteText: Text;

  constructor() {
    this.container = new Container();
  }

  public init(app: Application): void {
    // Background
    const bg = new Graphics();
    bg.rect(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
    bg.fill({ color: 0x000000 });
    this.container.addChild(bg);
    
    // Title
    const titleStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: 48,
      fill: UI_STYLES.COLORS.PRIMARY,
      fontWeight: 'bold'
    });
    const title = new Text({ text: 'SETTINGS', style: titleStyle });
    title.anchor.set(0.5);
    title.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 150);
    this.container.addChild(title);
    
    // Mute toggle button
    this.muteButton = this.createButton('SOUND: ON', 400);
    this.muteText = this.muteButton.children[1] as Text;
    this.muteButton.on('pointerdown', () => this.toggleMute());
    this.container.addChild(this.muteButton);
    
    // Back button
    const backBtn = this.createButton('BACK', 700);
    backBtn.on('pointerdown', () => this.onBackCallback?.());
    this.container.addChild(backBtn);
    
    // Update mute button text
    this.updateMuteButton();
  }

  private toggleMute(): void {
    const audioManager = AudioManager.getInstance();
    audioManager.toggleMute();
    this.updateMuteButton();
  }

  private updateMuteButton(): void {
    const audioManager = AudioManager.getInstance();
    const isMuted = audioManager.isMuted();
    this.muteText.text = isMuted ? 'SOUND: OFF' : 'SOUND: ON';
  }

  private createButton(text: string, y: number): Container {
    const button = new Container();
    button.position.set(GAME_CONFIG.WORLD_WIDTH / 2, y);
    button.eventMode = 'static';
    button.cursor = 'pointer';
    
    const bg = new Graphics();
    bg.roundRect(-150, -30, 300, 60, 8);
    bg.fill({ color: UI_STYLES.COLORS.BACKGROUND, alpha: 0.9 });
    bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
    button.addChild(bg);
    
    const textStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: UI_STYLES.FONT_SIZE_LARGE,
      fill: UI_STYLES.COLORS.SECONDARY,
      fontWeight: 'bold'
    });
    const buttonText = new Text({ text, style: textStyle });
    buttonText.anchor.set(0.5);
    button.addChild(buttonText);
    
    button.on('pointerover', () => {
      bg.stroke({ color: UI_STYLES.COLORS.PRIMARY, width: 3 });
      buttonText.style.fill = UI_STYLES.COLORS.PRIMARY;
    });
    
    button.on('pointerout', () => {
      bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
      buttonText.style.fill = UI_STYLES.COLORS.SECONDARY;
    });
    
    return button;
  }

  public show(): void { 
    this.container.visible = true;
    this.updateMuteButton();
  }
  public hide(): void { this.container.visible = false; }
  public setOnBack(cb: () => void): void { this.onBackCallback = cb; }
  public destroy(): void { this.container.destroy({ children: true }); }
}
```

### 5. Create Credits Screen

**File:** `src/ui/CreditsScreen.ts` (new)

```typescript
import { Application, Container, Graphics, Text, TextStyle } from 'pixi.js';
import { UI_STYLES } from './styles';
import { GAME_CONFIG } from '../types/constants';

export class CreditsScreen {
  public container: Container;
  private onBackCallback: (() => void) | null = null;

  constructor() {
    this.container = new Container();
  }

  public init(app: Application): void {
    // Background
    const bg = new Graphics();
    bg.rect(0, 0, GAME_CONFIG.WORLD_WIDTH, GAME_CONFIG.WORLD_HEIGHT);
    bg.fill({ color: 0x000000 });
    this.container.addChild(bg);
    
    // Title
    const titleStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: 48,
      fill: UI_STYLES.COLORS.PRIMARY,
      fontWeight: 'bold'
    });
    const title = new Text({ text: 'CREDITS', style: titleStyle });
    title.anchor.set(0.5);
    title.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 150);
    this.container.addChild(title);
    
    // Credits text
    const creditsStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: UI_STYLES.FONT_SIZE_MEDIUM,
      fill: UI_STYLES.COLORS.TEXT,
      align: 'center'
    });
    
    const creditsText = new Text({
      text: `KOBAYASHI MARU
      
Endless Tower Defense Game

Built with:
TypeScript • PixiJS 8 • bitECS
Web Audio API • Vite

Inspired by Star Trek

© 2025`,
      style: creditsStyle
    });
    creditsText.anchor.set(0.5);
    creditsText.position.set(GAME_CONFIG.WORLD_WIDTH / 2, 450);
    this.container.addChild(creditsText);
    
    // Back button
    const backBtn = this.createButton('BACK', 800);
    backBtn.on('pointerdown', () => this.onBackCallback?.());
    this.container.addChild(backBtn);
  }

  private createButton(text: string, y: number): Container {
    const button = new Container();
    button.position.set(GAME_CONFIG.WORLD_WIDTH / 2, y);
    button.eventMode = 'static';
    button.cursor = 'pointer';
    
    const bg = new Graphics();
    bg.roundRect(-100, -30, 200, 60, 8);
    bg.fill({ color: UI_STYLES.COLORS.BACKGROUND, alpha: 0.9 });
    bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
    button.addChild(bg);
    
    const textStyle = new TextStyle({
      fontFamily: UI_STYLES.FONT_FAMILY,
      fontSize: UI_STYLES.FONT_SIZE_LARGE,
      fill: UI_STYLES.COLORS.SECONDARY,
      fontWeight: 'bold'
    });
    const buttonText = new Text({ text, style: textStyle });
    buttonText.anchor.set(0.5);
    button.addChild(buttonText);
    
    button.on('pointerover', () => {
      bg.stroke({ color: UI_STYLES.COLORS.PRIMARY, width: 3 });
      buttonText.style.fill = UI_STYLES.COLORS.PRIMARY;
    });
    
    button.on('pointerout', () => {
      bg.stroke({ color: UI_STYLES.COLORS.SECONDARY, width: 2 });
      buttonText.style.fill = UI_STYLES.COLORS.SECONDARY;
    });
    
    return button;
  }

  public show(): void { this.container.visible = true; }
  public hide(): void { this.container.visible = false; }
  public setOnBack(cb: () => void): void { this.onBackCallback = cb; }
  public destroy(): void { this.container.destroy({ children: true }); }
}
```

### 6. Export Menu Components

**File:** `src/ui/index.ts` (modify)

```typescript
// Add to existing exports
export { MainMenu, MenuView } from './MainMenu';
export { TitleScreen } from './TitleScreen';
export { HighScoresScreen } from './HighScoresScreen';
export { SettingsScreen } from './SettingsScreen';
export { CreditsScreen } from './CreditsScreen';
```

### 7. Integrate with Game Class

**File:** `src/core/Game.ts` (modify)

Add main menu property:

```typescript
export class Game {
  // ... existing properties
  private mainMenu: MainMenu | null = null;
```

Initialize main menu in `init()`:

```typescript
async init(): Promise<void> {
  // ... existing init code (PixiJS, canvas, etc.)
  
  // Initialize main menu FIRST
  this.mainMenu = new MainMenu();
  this.mainMenu.init(this.app);
  this.mainMenu.setOnStart(() => this.startGame());
  
  // Show main menu
  this.mainMenu.show();
  
  // DON'T initialize gameplay yet - wait for start button
  // Comment out or remove: this.initializeGameplay();
  
  // ... rest of init (but skip gameplay initialization)
}
```

Add startGame method:

```typescript
/**
 * Start a new game from main menu
 */
public startGame(): void {
  // Hide main menu
  if (this.mainMenu) {
    this.mainMenu.hide();
  }
  
  // Show HUD
  if (this.hudManager) {
    this.hudManager.show();
  }
  
  // Initialize gameplay
  this.initializeGameplay();
  
  console.log('Game started from menu');
}
```

Update restart method to return to menu:

```typescript
restart(): void {
  // Hide game over screen
  if (this.gameOverScreen) {
    this.gameOverScreen.hide();
  }
  
  // Clear all existing entities
  this.clearAllEntities();
  
  // Reset all managers
  this.scoreManager.reset();
  this.resourceManager.reset();
  this.waveManager.reset();
  this.gameTime = 0;
  
  // Reset combat stats
  if (this.combatSystem) {
    this.combatSystem.resetStats();
  }
  
  // Reset game state
  this.gameState.reset();
  
  // Re-enable auto wave progression
  this.waveManager.setAutoStartNextWave(true);
  
  // Re-initialize gameplay
  this.initializeGameplay();
  
  console.log('Game restarted');
}
```

Add returnToMenu method:

```typescript
/**
 * Return to main menu from game
 */
public returnToMenu(): void {
  // Clear all entities
  this.clearAllEntities();
  
  // Reset managers
  this.scoreManager.reset();
  this.resourceManager.reset();
  this.waveManager.reset();
  this.gameTime = 0;
  
  // Reset game state
  this.gameState.reset();
  
  // Hide HUD
  if (this.hudManager) {
    this.hudManager.hide();
  }
  
  // Hide pause overlay if visible
  if (this.pauseOverlay) {
    this.pauseOverlay.hide();
  }
  
  // Show main menu
  if (this.mainMenu) {
    this.mainMenu.show();
  }
  
  console.log('Returned to main menu');
}
```

Update pause overlay quit button:

```typescript
// In init() where pause overlay is set up
this.pauseOverlay.setOnQuit(() => {
  this.resume();
  this.returnToMenu();
});
```

Update destroy method:

```typescript
destroy(): void {
  // ... existing destroy code
  
  if (this.mainMenu) {
    this.mainMenu.destroy();
  }
  
  // ... rest of destroy
}
```

## Testing

### Manual Testing Checklist

- [ ] Game loads to main menu (not gameplay)
- [ ] Title screen displays correctly
- [ ] All buttons are clickable
- [ ] "START GAME" button starts gameplay
- [ ] "HIGH SCORES" shows score list
- [ ] High scores display correctly (or "---" if empty)
- [ ] "SETTINGS" shows settings menu
- [ ] Mute toggle works in settings
- [ ] "CREDITS" shows credits screen
- [ ] "BACK" buttons return to title screen
- [ ] Hover effects work on all buttons
- [ ] ESC from pause menu returns to main menu
- [ ] Game over restart works
- [ ] Can play multiple games in one session
- [ ] No memory leaks

### Edge Cases

- [ ] Empty high scores list displays correctly
- [ ] Very long high scores list (10+ entries)
- [ ] Rapid button clicking
- [ ] Keyboard navigation (if implemented)
- [ ] Window resize during menu

## Success Criteria

- ✅ Main menu displays on game load
- ✅ Title screen with game name
- ✅ Start button begins gameplay
- ✅ High scores screen shows top 10 scores
- ✅ Settings menu with mute toggle
- ✅ Credits screen with attribution
- ✅ All navigation works correctly
- ✅ Professional LCARS-styled UI
- ✅ Smooth transitions between screens
- ✅ Can return to menu from game

## Notes for Agent

- Keep UI consistent with existing LCARS style
- Reuse button creation code where possible
- Main menu should be first thing player sees
- Don't initialize gameplay until start button clicked
- Settings can be expanded later (volume slider, etc.)
- Credits can be customized with your info
- Consider adding keyboard shortcuts (Enter to start, etc.)
- Test with empty high scores list

## Related Files

**New Files:**
- `src/ui/MainMenu.ts`
- `src/ui/TitleScreen.ts`
- `src/ui/HighScoresScreen.ts`
- `src/ui/SettingsScreen.ts`
- `src/ui/CreditsScreen.ts`

**Modified Files:**
- `src/ui/index.ts` (add exports)
- `src/core/Game.ts` (add menu integration)

## Next Steps

After implementing main menu:
1. Test all navigation flows
2. Adjust styling if needed
3. Add keyboard shortcuts (optional)
4. Consider adding animations (optional)
5. Game is now complete and ready for release!
